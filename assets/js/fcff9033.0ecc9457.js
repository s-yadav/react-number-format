"use strict";(self.webpackChunkreact_number_format=self.webpackChunkreact_number_format||[]).push([[497],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),m=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=m(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=m(n),d=r,f=p["".concat(s,".").concat(d)]||p[d]||c[d]||o;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var m=2;m<o;m++)i[m]=n[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8786:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>m,toc:()=>c});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={title:"Customization",sidebar_position:5},s=void 0,m={unversionedId:"customization",id:"customization",title:"Customization",description:"Concept",source:"@site/docs/customization.md",sourceDirName:".",slug:"/customization",permalink:"/react-number-format/docs/customization",editUrl:"https://github.com/s-yadav/react-number-format/docs/customization.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Customization",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Pattern Format",permalink:"/react-number-format/docs/pattern_format"},next:{title:"Migration guide",permalink:"/react-number-format/docs/migration"}},u={},c=[{value:"Concept",id:"concept",level:2},{value:"Examples",id:"examples",level:2},{value:"Intl.NumberFormat based formatting",id:"intlnumberformat-based-formatting",level:3},{value:"Card expiry field",id:"card-expiry-field",level:3},{value:"Card expiry field with usePatternFormat",id:"card-expiry-field-with-usepatternformat",level:3},{value:"Custom numeral example",id:"custom-numeral-example",level:3},{value:"AllowEmptyFormatting on NumericFormat",id:"allowemptyformatting-on-numericformat",level:3},{value:"Using parentheses to express negative numbers",id:"using-parentheses-to-express-negative-numbers",level:3}],p={toc:c};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"concept"},"Concept"),(0,o.kt)("p",null,"React Number Format v5 is a complete rewrite with a goal of keeping it fully customizable to support all the custom case different product can have."),(0,o.kt)("p",null,"The primary thing which react number format controls is apply formatting in place (in the input) while managing correct caret position. It tries to understand what user is trying to do, add number, cut/paste, delete, and manage cursor position accordingly."),(0,o.kt)("p",null,"At the core of React number format lies NumberFormatBase, which works on three main props controlled from parent."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"format")," ",(0,o.kt)("inlineCode",{parentName:"li"},"(numStr: string) => string"),": A format function which can turn any numeric string to a formatted string."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"removeFormatting")," ",(0,o.kt)("inlineCode",{parentName:"li"},"(formattedStr: string) => string"),": A function to removing formatting from a formatted string and return numeric string."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"getCaretBoundary")," ",(0,o.kt)("inlineCode",{parentName:"li"},"(formattedStr: string) => boolean[]"),": A function given a formatted string, returns boundaries of valid cursor position. basically an array of boolean, where index of specify caret position. true at a index signifies user can put their caret at the position, false means the caret position is not allowed and the caret will move to closet allowed position.")),(0,o.kt)("p",null,"Most of the time you don't have to define getCaretBoundary, as the default one is enough, but in case you need to define, it looks something like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function caretUnknownFormatBoundary(formattedValue) {\n  const boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(() => true);\n\n  for (let i = 0, ln = boundaryAry.length; i < ln; i++) {\n    // consider caret to be in boundary if it is before or after numeric value\n    boundaryAry[i] = Boolean(\n      formattedValue[i].match(/\\d/) || formattedValue[i - 1].match(/\\d/);,\n    );\n  }\n\n  return boundaryAry;\n}\n")),(0,o.kt)("p",null,"There are few more props to handle some corner case."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"isValidInputCharacter")," ",(0,o.kt)("inlineCode",{parentName:"li"},"(char: sting) => boolean"),": A function to tell if a character in the formatted value is a valid typeable character. You don't need to pass it most of the time, as it defaults numeric characters (0-9). But case like additional character is allowed to type, for example decimal separator in currency format."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"isCharacterSame")," ",(0,o.kt)("inlineCode",{parentName:"li"},"(compareProps: CompareProps) => boolean"),": Some time we would like to allow user pressing different key and that being interpreted as different key like custom numerals, or letting user press ",(0,o.kt)("inlineCode",{parentName:"li"},".")," for decimal separator when custom decimalSeparator is provided. In such case we need to inform the library that the two characters are same.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type CompareProps = {\n  currentValue: string, // current value in the input, before applying any formatting\n  lastValue: string, // last formatted value\n  formattedValue: string, // current formatted value.\n  currentValueIndex: number, // character index in currentValue which we are comparing\n  formattedValueIndex: number, // character index in formattedValue which we are comparing\n};\n")),(0,o.kt)("p",null,"Check the usage in ",(0,o.kt)("a",{parentName:"p",href:"#custom-numeral-example"},"custom numeral example"),"."),(0,o.kt)("p",null,"Apart from this prop some key handling are required depending on use case which can be done using native events, onKeyDown/onKeyUp etc."),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)("p",null,"To give an example a basic implementation of number formatting if we have simple use case to format number without decimals and negative number support."),(0,o.kt)("h3",{id:"intlnumberformat-based-formatting"},"Intl.NumberFormat based formatting"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { NumberFormatBase } from 'react-number-format';\n\nfunction MyCustomNumberFormat(props) {\n  const format = (numStr) => {\n    if (numStr === '') return '';\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: 'USD',\n      maximumFractionDigits: 0,\n    }).format(numStr);\n  };\n\n  return <NumberFormatBase {...props} format={format} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/custom-numeric-format-ovl6km?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"Custom Numeric Format",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("p",null,"Another example of card expiry field."),(0,o.kt)("h3",{id:"card-expiry-field"},"Card expiry field"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { NumberFormatBase } from 'react-number-format';\n\nfunction CardExpiry(props) {\n  const format = (val) => {\n    if (val === '') return '';\n    let month = val.substring(0, 2);\n    const year = val.substring(2, 4);\n\n    if (month.length === 1 && month[0] > 1) {\n      month = `0${month[0]}`;\n    } else if (month.length === 2) {\n      // set the lower and upper boundary\n      if (Number(month) === 0) {\n        month = `01`;\n      } else if (Number(month) > 12) {\n        month = '12';\n      }\n    }\n\n    return `${month}/${year}`;\n  };\n\n  return <NumberFormatBase {...props} format={format} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/card-expiry-field-eovgoh?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"Card Expiry Field",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("p",null,"A couple of time we want to get all the features of NumericFormat or PatterFormat, and apply some customization on top of it. Well NumberFormat allows to do that as well. It provides\n",(0,o.kt)("inlineCode",{parentName:"p"},"usePatternFormat")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useNumericFormat")," hook which can be used in conjunction with NumberFormatBase."),(0,o.kt)("p",null,"Let's take the same example of Card Expiry field."),(0,o.kt)("h3",{id:"card-expiry-field-with-usepatternformat"},"Card expiry field with usePatternFormat"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function CardExpiry(props) {\n  /**\n   * usePatternFormat, returns all the props required for NumberFormatBase\n   * which we can extend in between\n   */\n  const { format, ...rest } = usePatternFormat({ ...props, format: '##/##' });\n\n  const _format = (val) => {\n    let month = val.substring(0, 2);\n    const year = val.substring(2, 4);\n\n    if (month.length === 1 && month[0] > 1) {\n      month = `0${month[0]}`;\n    } else if (month.length === 2) {\n      // set the lower and upper boundary\n      if (Number(month) === 0) {\n        month = `01`;\n      } else if (Number(month) > 12) {\n        month = '12';\n      }\n    }\n\n    return format(`${month}${year}`);\n  };\n\n  return <NumberFormatBase format={_format} {...rest} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/card-expiry-field-pattern-format-3yzksf?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"Card Expiry Field (Pattern Format)",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("p",null,"Another example for NumericFormat could be support for custom numerals."),(0,o.kt)("h3",{id:"custom-numeral-example"},"Custom numeral example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const persianNumeral = ['\u06f0', '\u06f1', '\u06f2', '\u06f3', '\u06f4', '\u06f5', '\u06f6', '\u06f7', '\u06f8', '\u06f9'];\n\nfunction CustomNumeralNumericFormat(props) {\n  const { format, removeFormatting, isCharacterSame, ...rest } = useNumericFormat(props);\n\n  const _format = (val) => {\n    const _val = format(val);\n    return _val.replace(/\\d/g, ($1) => persianNumeral[Number($1)]);\n  };\n\n  const _removeFormatting = (val) => {\n    const _val = val.replace(new RegExp(persianNumeral.join('|'), 'g'), ($1) =>\n      persianNumeral.indexOf($1),\n    );\n\n    return removeFormatting(_val);\n  };\n\n  const _isCharacterSame = (compareMeta) => {\n    const isCharSame = isCharacterSame(compareMeta);\n    const { formattedValue, currentValue, formattedValueIndex, currentValueIndex } = compareMeta;\n    const curChar = currentValue[currentValueIndex];\n    const newChar = formattedValue[formattedValueIndex];\n    const curPersianChar = persianNumeral[Number(curChar)] ?? curChar;\n    const newPersianChar = persianNumeral[Number(newChar)] ?? newChar;\n\n    return isCharSame || curPersianChar || newPersianChar;\n  };\n\n  return (\n    <NumberFormatBase\n      format={_format}\n      removeFormatting={_removeFormatting}\n      isCharacterSame={_isCharacterSame}\n      {...rest}\n    />\n  );\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/custom-numeral-numer-format-forked-s8e1s4?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"Custom numeral example",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("h3",{id:"allowemptyformatting-on-numericformat"},"AllowEmptyFormatting on NumericFormat"),(0,o.kt)("p",null,"Currently allowEmptyFormatting is only available on the pattern lock, while it isn't a common usecase in NumericFormat, you still might want that behavior, you can achieve it like following."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function CustomNumberFormat(props) {\n  const { prefix = '', suffix = '', allowEmptyFormatting } = props;\n  const { format, ...numberFormatBaseProps } = useNumericFormat(props);\n  const _format = (numStr, props) => {\n    const formattedValue = format(numStr, props);\n    return allowEmptyFormatting && formattedValue === '' ? prefix + suffix : formattedValue;\n  };\n\n  return <NumberFormatBase {...numberFormatBaseProps} format={_format} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/numeric-format-allowemptyformat-zt3mh8?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"AllowEmptyFormatting on NumericFormat",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("h3",{id:"using-parentheses-to-express-negative-numbers"},"Using parentheses to express negative numbers"),(0,o.kt)("p",null,"In some financial application we may want to express negative numbers enclosed with parentheses ",(0,o.kt)("inlineCode",{parentName:"p"},"($111,222)")," as opposed to negative sign ahead of the number ",(0,o.kt)("inlineCode",{parentName:"p"},"-$111,222"),". This can be implemented outside of the lib since v5."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function extractNegationAndNumber(value) {\n  const hasNegation = typeof value === 'number' ? value < 0 : value?.[0] === '-';\n  if (typeof value === 'number' && hasNegation) {\n    value = value * -1;\n  } else if (typeof value === 'string' && hasNegation) {\n    value = value.substring(1);\n  }\n\n  return { hasNegation, value };\n}\n\nfunction CustomNegationNumberFormat({\n  prefix = '',\n  suffix = '',\n  value,\n  defaultValue,\n  onValueChange,\n  ...restProps\n}) {\n  const [hasNegation, toggleNegation] = useState(\n    extractNegationAndNumber(value ?? defaultValue).hasNegation,\n  );\n  const [internalValue, setInternalValue] = useState(\n    extractNegationAndNumber(value ?? defaultValue).value,\n  );\n  useEffect(() => {\n    const { hasNegation, value: internalValue } = extractNegationAndNumber(value);\n    setInternalValue(internalValue);\n    toggleNegation(hasNegation);\n  }, [value]);\n\n  const _onValueChange = (values, sourceInfo) => {\n    if (!onValueChange) return;\n\n    if (!hasNegation) return onValueChange(values);\n\n    const { formattedValue, value, floatValue } = values;\n\n    onValueChange(\n      {\n        // don't have prefix and suffix added if we just get the number\n        formattedValue: value === '' ? '-' : formattedValue.replace(/^\\((.*)\\)$/, '-$1'),\n        value: hasNegation ? `-${value}` : value,\n        floatValue: hasNegation && !isNaN(floatValue) ? -floatValue : floatValue,\n      },\n      sourceInfo,\n    );\n  };\n\n  const props = {\n    prefix: hasNegation ? '(' + prefix : prefix,\n    suffix: hasNegation ? suffix + ')' : suffix,\n    // as we are controlling the negation logic outside, we don't want numeric format to handle this\n    allowNegative: false,\n    value: internalValue,\n    onValueChange: _onValueChange,\n    ...restProps,\n  };\n  const { format, onKeyDown, ...numberFormatBaseProps } = useNumericFormat(props);\n\n  const _format = (numStr) => {\n    const formattedValue = format(numStr, props);\n    // if negation is present we need to always show negation with prefix and suffix even if value is empty\n    return formattedValue === '' && hasNegation ? props.prefix + props.suffix : formattedValue;\n  };\n\n  const _onKeyDown = (e) => {\n    const el = e.target;\n    const { key } = e;\n    const { selectionStart, selectionEnd, value = '' } = el;\n\n    // if multiple characters are selected and user hits backspace, no need to handle anything manually\n    if (selectionStart !== selectionEnd) {\n      onKeyDown(e);\n      return;\n    }\n\n    // if user is pressing '-' we want to change it to '()', so mark there is negation in the number\n    if (key === '-') {\n      toggleNegation(!hasNegation);\n      e.preventDefault();\n      return;\n    }\n\n    if (key === 'Backspace' && value[0] === '(' && selectionStart === props.prefix.length) {\n      toggleNegation(false);\n      e.preventDefault();\n      return;\n    }\n\n    onKeyDown(e);\n  };\n\n  return <NumberFormatBase {...numberFormatBaseProps} onKeyDown={_onKeyDown} format={_format} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/parentheses-for-negation-forked-jn42cp?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"Using parentheses to express negative numbers",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})))}d.isMDXComponent=!0}}]);