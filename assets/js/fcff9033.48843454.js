"use strict";(self.webpackChunkreact_number_format=self.webpackChunkreact_number_format||[]).push([[497],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),m=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=m(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=m(n),d=r,f=p["".concat(s,".").concat(d)]||p[d]||c[d]||o;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var m=2;m<o;m++)i[m]=n[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8786:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>m,toc:()=>c});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={title:"Customization",sidebar_position:5},s=void 0,m={unversionedId:"customization",id:"customization",title:"Customization",description:"Concept",source:"@site/docs/customization.md",sourceDirName:".",slug:"/customization",permalink:"/react-number-format/docs/customization",editUrl:"https://github.com/s-yadav/react-number-format/docs/customization.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Customization",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Pattern Format",permalink:"/react-number-format/docs/pattern_format"},next:{title:"Migration guide",permalink:"/react-number-format/docs/migration"}},u={},c=[{value:"Concept",id:"concept",level:2},{value:"Examples",id:"examples",level:2},{value:"Intl.NumberFormat based formatting",id:"intlnumberformat-based-formatting",level:3},{value:"Card expiry field",id:"card-expiry-field",level:3},{value:"Card expiry field with usePatternFormat",id:"card-expiry-field-with-usepatternformat",level:3},{value:"Custom numeral example",id:"custom-numeral-example",level:3},{value:"AllowEmptyFormatting on NumericFormat",id:"allowemptyformatting-on-numericformat",level:3},{value:"Using parentheses to express negative numbers",id:"using-parentheses-to-express-negative-numbers",level:3},{value:"IBAN account input field with pattern",id:"iban-account-input-field-with-pattern",level:3}],p={toc:c};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"concept"},"Concept"),(0,o.kt)("p",null,"React Number Format v5 is a complete rewrite with a goal of keeping it fully customizable to support all the custom case different product can have."),(0,o.kt)("p",null,"The primary thing which react number format controls is apply formatting in place (in the input) while managing correct caret position. It tries to understand what user is trying to do, add number, cut/paste, delete, and manage cursor position accordingly."),(0,o.kt)("p",null,"At the core of React number format lies NumberFormatBase, which works on three main props controlled from parent."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"format")," ",(0,o.kt)("inlineCode",{parentName:"li"},"(numStr: string) => string"),": A format function which can turn any numeric string to a formatted string."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"removeFormatting")," ",(0,o.kt)("inlineCode",{parentName:"li"},"(formattedStr: string) => string"),": A function to removing formatting from a formatted string and return numeric string."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"getCaretBoundary")," ",(0,o.kt)("inlineCode",{parentName:"li"},"(formattedStr: string) => boolean[]"),": A function given a formatted string, returns boundaries of valid cursor position. basically an array of boolean, where index of specify caret position. true at a index signifies user can put their caret at the position, false means the caret position is not allowed and the caret will move to closet allowed position.")),(0,o.kt)("p",null,"Most of the time you don't have to define getCaretBoundary, as the default one is enough, but in case you need to define, it looks something like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function caretUnknownFormatBoundary(formattedValue) {\n  const boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(() => true);\n\n  for (let i = 0, ln = boundaryAry.length; i < ln; i++) {\n    // consider caret to be in boundary if it is before or after numeric value\n    boundaryAry[i] = Boolean(\n      formattedValue[i].match(/\\d/) || formattedValue[i - 1].match(/\\d/);,\n    );\n  }\n\n  return boundaryAry;\n}\n")),(0,o.kt)("p",null,"There are few more props to handle some corner case."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"isValidInputCharacter")," ",(0,o.kt)("inlineCode",{parentName:"li"},"(char: sting) => boolean"),": A function to tell if a character in the formatted value is a valid typeable character. You don't need to pass it most of the time, as it defaults numeric characters (0-9). But case like additional character is allowed to type, for example decimal separator in currency format."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"isCharacterSame")," ",(0,o.kt)("inlineCode",{parentName:"li"},"(compareProps: CompareProps) => boolean"),": Some time we would like to allow user pressing different key and that being interpreted as different key like custom numerals, or letting user press ",(0,o.kt)("inlineCode",{parentName:"li"},".")," for decimal separator when custom decimalSeparator is provided. In such case we need to inform the library that the two characters are same.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type CompareProps = {\n  currentValue: string, // current value in the input, before applying any formatting\n  lastValue: string, // last formatted value\n  formattedValue: string, // current formatted value.\n  currentValueIndex: number, // character index in currentValue which we are comparing\n  formattedValueIndex: number, // character index in formattedValue which we are comparing\n};\n")),(0,o.kt)("p",null,"Check the usage in ",(0,o.kt)("a",{parentName:"p",href:"#custom-numeral-example"},"custom numeral example"),"."),(0,o.kt)("p",null,"Apart from this prop some key handling are required depending on use case which can be done using native events, onKeyDown/onKeyUp etc."),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)("p",null,"To give an example a basic implementation of number formatting if we have simple use case to format number without decimals and negative number support."),(0,o.kt)("h3",{id:"intlnumberformat-based-formatting"},"Intl.NumberFormat based formatting"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { NumberFormatBase } from 'react-number-format';\n\nfunction MyCustomNumberFormat(props) {\n  const format = (numStr) => {\n    if (numStr === '') return '';\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: 'USD',\n      maximumFractionDigits: 0,\n    }).format(numStr);\n  };\n\n  return <NumberFormatBase {...props} format={format} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/custom-numeric-format-ovl6km?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"Custom Numeric Format",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("p",null,"Another example of card expiry field."),(0,o.kt)("h3",{id:"card-expiry-field"},"Card expiry field"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { NumberFormatBase } from 'react-number-format';\n\nfunction CardExpiry(props) {\n  const format = (val) => {\n    if (val === '') return '';\n    let month = val.substring(0, 2);\n    const year = val.substring(2, 4);\n\n    if (month.length === 1 && month[0] > 1) {\n      month = `0${month[0]}`;\n    } else if (month.length === 2) {\n      // set the lower and upper boundary\n      if (Number(month) === 0) {\n        month = `01`;\n      } else if (Number(month) > 12) {\n        month = '12';\n      }\n    }\n\n    return `${month}/${year}`;\n  };\n\n  const onKeyDown = (e) => {\n    const { target } = e;\n    const { value, selectionStart } = target;\n    console.log(value);\n    if (e.key === '/' && value[selectionStart] === '/') {\n      // if there is number before slash with just one character add 0 prefix\n      if (value.split('/')[0].length === 1) {\n        target.value = `0${value}`;\n        target.selectionStart++;\n      }\n\n      target.selectionStart++;\n      e.preventDefault();\n    }\n  };\n\n  return <NumberFormatBase {...props} format={format} onKeyDown={onKeyDown} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/card-expiry-field-eovgoh?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"Card Expiry Field",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("p",null,"A couple of time we want to get all the features of NumericFormat or PatternFormat, and apply some customization on top of it. Well NumberFormat allows to do that as well. It provides\n",(0,o.kt)("inlineCode",{parentName:"p"},"usePatternFormat")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useNumericFormat")," hook which can be used in conjunction with NumberFormatBase."),(0,o.kt)("p",null,"Let's take the same example of Card Expiry field."),(0,o.kt)("h3",{id:"card-expiry-field-with-usepatternformat"},"Card expiry field with usePatternFormat"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function CardExpiry(props) {\n  /**\n   * usePatternFormat, returns all the props required for NumberFormatBase\n   * which we can extend in between\n   */\n  const { format, ...rest } = usePatternFormat({ ...props, format: '##/##' });\n\n  const _format = (val) => {\n    let month = val.substring(0, 2);\n    const year = val.substring(2, 4);\n\n    if (month.length === 1 && month[0] > 1) {\n      month = `0${month[0]}`;\n    } else if (month.length === 2) {\n      // set the lower and upper boundary\n      if (Number(month) === 0) {\n        month = `01`;\n      } else if (Number(month) > 12) {\n        month = '12';\n      }\n    }\n\n    return format(`${month}${year}`);\n  };\n\n  return <NumberFormatBase format={_format} {...rest} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/card-expiry-field-pattern-format-3yzksf?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"Card Expiry Field (Pattern Format)",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("p",null,"Another example for NumericFormat could be support for custom numerals."),(0,o.kt)("h3",{id:"custom-numeral-example"},"Custom numeral example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const persianNumeral = ['\u06f0', '\u06f1', '\u06f2', '\u06f3', '\u06f4', '\u06f5', '\u06f6', '\u06f7', '\u06f8', '\u06f9'];\n\nfunction CustomNumeralNumericFormat(props) {\n  const { format, removeFormatting, isCharacterSame, ...rest } = useNumericFormat(props);\n\n  const _format = (val) => {\n    const _val = format(val);\n\n    return _val.replace(/\\d/g, ($1) => persianNumeral[Number($1)]);\n  };\n\n  const _removeFormatting = (val) => {\n    const _val = val.replace(new RegExp(persianNumeral.join('|'), 'g'), ($1) =>\n      persianNumeral.indexOf($1),\n    );\n\n    return removeFormatting(_val);\n  };\n\n  const _isCharacterSame = (compareMeta) => {\n    const isCharSame = isCharacterSame(compareMeta);\n    const { formattedValue, currentValue, formattedValueIndex, currentValueIndex } = compareMeta;\n    const curChar = currentValue[currentValueIndex];\n    const newChar = formattedValue[formattedValueIndex];\n    const curPersianChar = persianNumeral[Number(curChar)] ?? curChar;\n    const newPersianChar = persianNumeral[Number(newChar)] ?? newChar;\n\n    return isCharSame || curPersianChar === newPersianChar;\n  };\n\n  return (\n    <NumberFormatBase\n      format={_format}\n      removeFormatting={_removeFormatting}\n      isCharacterSame={_isCharacterSame}\n      {...rest}\n    />\n  );\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/custom-numeral-numer-format-forked-s8e1s4?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"Custom numeral example",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("h3",{id:"allowemptyformatting-on-numericformat"},"AllowEmptyFormatting on NumericFormat"),(0,o.kt)("p",null,"Currently allowEmptyFormatting is only available on the pattern lock, while it isn't a common usecase in NumericFormat, you still might want that behavior, you can achieve it like following."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function CustomNumberFormat(props) {\n  const { prefix = '', suffix = '', allowEmptyFormatting } = props;\n  const { format, ...numberFormatBaseProps } = useNumericFormat(props);\n  const _format = (numStr, props) => {\n    const formattedValue = format(numStr, props);\n    return allowEmptyFormatting && formattedValue === '' ? prefix + suffix : formattedValue;\n  };\n\n  return <NumberFormatBase {...numberFormatBaseProps} format={_format} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/numeric-format-allowemptyformat-zt3mh8?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"AllowEmptyFormatting on NumericFormat",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("h3",{id:"using-parentheses-to-express-negative-numbers"},"Using parentheses to express negative numbers"),(0,o.kt)("p",null,"In some financial application we may want to express negative numbers enclosed with parentheses ",(0,o.kt)("inlineCode",{parentName:"p"},"($111,222)")," as opposed to negative sign ahead of the number ",(0,o.kt)("inlineCode",{parentName:"p"},"-$111,222"),". This can be implemented outside of the lib since v5."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const NEGATION_FORMAT_REGEX = /^\\((.*)\\)$/;\n\nfunction extractNegationAndNumber(value) {\n  let hasNegation = false;\n  if (typeof value === 'number') {\n    hasNegation = value < 0;\n    value = hasNegation ? value * -1 : value;\n  } else if (value?.[0] === '-') {\n    hasNegation = true;\n    value = value.substring(1);\n  } else if (value?.match(NEGATION_FORMAT_REGEX)) {\n    hasNegation = true;\n    value = value.replace(NEGATION_FORMAT_REGEX, '$1');\n  }\n\n  return { hasNegation, value };\n}\n\nfunction CustomNegationNumberFormat({\n  prefix = '',\n  suffix = '',\n  value,\n  defaultValue,\n  onValueChange,\n  ...restProps\n}) {\n  const [hasNegation, toggleNegation] = useState(\n    extractNegationAndNumber(value ?? defaultValue).hasNegation,\n  );\n  const [internalValue, setInternalValue] = useState(\n    extractNegationAndNumber(value ?? defaultValue).value,\n  );\n  useEffect(() => {\n    const { hasNegation, value: internalValue } = extractNegationAndNumber(value);\n    setInternalValue(internalValue);\n    toggleNegation(hasNegation);\n  }, [value]);\n\n  const _onValueChange = (values, sourceInfo) => {\n    if (!onValueChange) return;\n\n    const { formattedValue, value, floatValue } = values;\n    onValueChange(\n      {\n        formattedValue,\n        value: hasNegation ? `-${value}` : value,\n        floatValue: hasNegation && !isNaN(floatValue) ? -floatValue : floatValue,\n      },\n      sourceInfo,\n    );\n  };\n\n  const props = {\n    prefix: hasNegation ? '(' + prefix : prefix,\n    suffix: hasNegation ? suffix + ')' : suffix,\n    // as we are controlling the negation logic outside, we don't want numeric format to handle this\n    allowNegative: false,\n    value: internalValue,\n    onValueChange: _onValueChange,\n    ...restProps,\n  };\n  const { format, onKeyDown, ...numberFormatBaseProps } = useNumericFormat(props);\n\n  const _format = (numStr) => {\n    const formattedValue = format(numStr, props);\n    // if negation is present we need to always show negation with prefix and suffix even if value is empty\n    return formattedValue === '' && hasNegation ? props.prefix + props.suffix : formattedValue;\n  };\n\n  const _onKeyDown = (e) => {\n    const el = e.target;\n    const { key } = e;\n    const { selectionStart, selectionEnd, value = '' } = el;\n\n    // if every thing is selected and deleted remove the negation as well\n    if (selectionStart !== selectionEnd) {\n      // if multiple characters are selected and user hits backspace, no need to handle anything manually\n      onKeyDown(e);\n      return;\n    }\n\n    // if user is pressing '-' we want to change it to '()', so mark there is negation in the number\n    if (key === '-') {\n      toggleNegation((hasNegation) => !hasNegation);\n      e.preventDefault();\n      return;\n    }\n\n    if (key === 'Backspace' && value[0] === '(' && selectionStart === props.prefix.length) {\n      toggleNegation(false);\n      e.preventDefault();\n      return;\n    }\n\n    onKeyDown(e);\n  };\n\n  return <NumberFormatBase {...numberFormatBaseProps} onKeyDown={_onKeyDown} format={_format} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/parentheses-for-negation-forked-jn42cp?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"Using parentheses to express negative numbers",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})),(0,o.kt)("h3",{id:"iban-account-input-field-with-pattern"},"IBAN account input field with pattern"),(0,o.kt)("p",null,"In order to enter IBAN (International Bank Account Number) accounts into an input field the field requires specific pattern (quartets of characters/digits) and should allow typing in digits and letters which get converted to uppercase. Each country has a predefined format of the IBAN value which defines which the correct sequence of letters and digits. These formats are beyond this example and can be checked in libraries that validate IBAN accounts."),(0,o.kt)("p",null,"(Example code is written in Typescript)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface IBANInputProps extends NumberFormatBaseProps {\n  onChange: ChangeEventHandler<HTMLInputElement>;\n}\n\nconst IBANInputDef: FunctionComponent<IBANInputProps> = ({ onChange, ...props }) => (\n  <NumberFormatBase\n    {...props}\n    type=\"text\"\n    format={(value) =>\n      value\n        .replace(/\\s+/g, '')\n        .replace(/([a-z0-9]{4})/gi, '$1 ')\n        .trim()\n        .toLocaleUpperCase()\n    }\n    removeFormatting={(value) => value.replace(/\\s+/gi, '')}\n    isValidInputCharacter={(char) => /^[a-z0-9]$/i.test(char)}\n    getCaretBoundary={(value) =>\n      Array(value.length + 1)\n        .fill(0)\n        .map((v) => true)\n    }\n    onValueChange={(values, { event }) =>\n      onChange(\n        Object.assign({} as ChangeEvent<HTMLInputElement>, event, {\n          target: { name: props.name, value: values.value.toLocaleUpperCase() },\n        }),\n      )\n    }\n    onKeyDown={(e) =>\n      !/^(?:[a-z0-9]|Backspace|Delete|Home|End|ArrowLeft|ArrowRight|Shift|CapsLock|Control|NumLock|Tab|Paste|Redo|Undo)$/i.test(\n        e.key,\n      ) && e.preventDefault()\n    }\n  />\n);\n\nconst IBANInput = forwardRef<HTMLInputElement, IBANInputProps>((props, ref) => (\n  <IBANInputDef {...props} getInputRef={ref} />\n));\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Demo"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/iban-input-field-czr3fh?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"IBAN Input Field",className:"csb",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})))}d.isMDXComponent=!0}}]);